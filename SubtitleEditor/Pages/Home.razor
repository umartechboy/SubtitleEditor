@page "/"
@using System.Text
@using Whisper.net
@using Whisper.net.Ggml
@using FFmpegBlazor
@using MudBlazor
@using MudBlazor.Utilities
@using SkiaSharp.Views.Blazor
@using SubtitleEditor.Editors
@using SubtitleEditor.SectionDef

@inject IDialogService DialogService
@inject IJSRuntime Runtime
@inject ISnackbar Snackbar
@inject HttpClient HTTP

<PageTitle>Home</PageTitle>

<MudGrid>
    <MudItem xs="8">
        <MudItem xs="12" Class="my-2">
		    <MudPaper Class="d-flex object-center mud-width-full">
			    <SkiaSharp.Views.Blazor.SKGLView @ref=renderPreview
											     IgnorePixelScaling="true"
											     OnPaintSurface="OnRenderPaint"
											     style="width: 100%; height: 70vh;margin: 0px 0px 0px 0px;"></SkiaSharp.Views.Blazor.SKGLView>
            </MudPaper>
        </MudItem>
        <MudItem xs="12">
		    <MudPaper Class="d-flex object-center mud-width-full">
                <div style="width: 100%; height: 25vh;">
                    <SectionBarWebControl @ref=sectionBarControl
                                          SeekUpdate="SeekUpdate"
                                          RenderPreview="@RenderPreview"
                                          EditClip="EditClipRequest"></SectionBarWebControl>
                </div>
            </MudPaper>
        </MudItem>
	</MudItem>

    <MudItem md="4">
        <MudAppBar Color="Color.Transparent" Fixed="false" Elevation="0">
            <MudText Typo="Typo.h3">@CurrentTime</MudText>
            <MudSpacer />
            <MudIconButton Icon="@Icons.Material.Outlined.MenuOpen" Color="Color.Inherit" OnClick="() => menuOpen = true"/>
        </MudAppBar>
        <MudItem md="12">
            <MudPaper Class="d-flex align-center justify-center mud-width-full py-8 px-2">
                @if (ClipUnderEditing is SubtitleClip)
                {
                    <SubtitleEditor.Editors.SubtitleClipEditor 
                    OnAChange="SubtitleEditorOnAChange"
                    Text="@ClipEditorSource"
                    FontFamily="@SubtitleEditorFontFamily"
                    TypeFaces="@TypeFaces"
                    FontSize="@SubtitleEditorFontSize"
                    YPosition="@SubtitleEditorYPosition"
                    ShadowSize="@SubtitleEditorShadowSize"
                    ShadowDistance="@SubtitleEditorShadowDistance"
                    TextColor="@SubtitleEditorTextColor"
                    ShadowColor="@SubtitleEditorShadowColor"
                    Overlap="@SubtitleEditorOverlap"
                    StartingHH="@ClipEditorStartingHH"
                    StartingMM="@ClipEditorStartingMM"
                    StartingSS="@ClipEditorStartingSS"
                    StartingFF="@ClipEditorStartingFF"
                    DurationHH="@ClipEditorDurationHH"
                    DurationMM="@ClipEditorDurationMM"
                    DurationSS="@ClipEditorDurationSS"
                    DurationFF="@ClipEditorDurationFF"></SubtitleEditor.Editors.SubtitleClipEditor>
                }
                @if (ClipUnderEditing is PhotoClip)
                {
                    
                    <SubtitleEditor.Editors.PhotoClipEditor 
                    OnAChange="PhotoEditorOnAChange"
                    SelectedImage="@ClipEditorSource"
                    SelectedImageData="@PhotoEditorData"
                    Size="GraphicEditorSize"
                    XPosition="GraphicEditorXPosition"
                    YPosition="GraphicEditorYPosition"
                    StartingHH="@ClipEditorStartingHH"
                    StartingMM="@ClipEditorStartingMM"
                    StartingSS="@ClipEditorStartingSS"
                    StartingFF="@ClipEditorStartingFF"
                    DurationHH="@ClipEditorDurationHH"
                    DurationMM="@ClipEditorDurationMM"
                    DurationSS="@ClipEditorDurationSS"
                    DurationFF="@ClipEditorDurationFF"></SubtitleEditor.Editors.PhotoClipEditor>
                }
                @if (ClipUnderEditing is VideoClip)
                {

                    <SubtitleEditor.Editors.VideoClipEditor 
                    OnAChange="VideoEditorOnAChange"
                    SelectedVideo="@ClipEditorSource"
                    SelectedVideoData="@VideoEditorData"
                    Size="GraphicEditorSize"
                    XPosition="GraphicEditorXPosition"
                    YPosition="GraphicEditorYPosition"
                    StartingHH="@ClipEditorStartingHH"
                    StartingMM="@ClipEditorStartingMM"
                    StartingSS="@ClipEditorStartingSS"
                    StartingFF="@ClipEditorStartingFF"
                    DurationHH="@ClipEditorDurationHH"
                    DurationMM="@ClipEditorDurationMM"
                    DurationSS="@ClipEditorDurationSS"
                    DurationFF="@ClipEditorDurationFF"></SubtitleEditor.Editors.VideoClipEditor>
                }
                @if(ClipUnderEditing == null)
                {
                    <MudText Typo="Typo.body2" Align="Align.Center">No clips are selected</MudText>
                }
            </MudPaper>
        </MudItem>
	</MudItem>
</MudGrid>

@* Main Menu *@
<MudDrawer @bind-Open="@menuOpen" Anchor="Anchor.End" Elevation="1" Variant="@DrawerVariant.Temporary">
    <MudDrawerHeader>
        <MudText Typo="Typo.h6">The Lyrics App</MudText>
    </MudDrawerHeader>
    <MudNavMenu>
        <MudNavMenu>
            <MudText Typo="Typo.h6" Class="px-4">Options</MudText>
            <MudText Typo="Typo.body2" Class="px-4 mud-text-secondary">Choose an option</MudText>
            <MudDivider Class="my-2" />
            <MudNavGroup Title="Settings" Expanded="true">
                <MudNavLink OnClick="() => {renderMenuOpen = true; menuOpen = false; }">Render</MudNavLink>
                @if (renderOutputFile != "")
                {
                    <MudNavLink OnClick="() => TriggerDownload(renderOutputFile)">Download rendered file</MudNavLink>
                }
            </MudNavGroup>
            <MudNavGroup Title="Lyrics" Expanded="true">
                <MudNavLink OnClick="() => whisperMenuOpen = true">Extract Lyrics</MudNavLink>
            </MudNavGroup>
        </MudNavMenu>
    </MudNavMenu>
</MudDrawer>

@* Render Menu *@
<MudDialog @bind-IsVisible="renderMenuOpen" Options="new DialogOptions() { FullWidth = true }">
    <TitleContent>
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@Icons.Material.Filled.AutoFixHigh" Class="mr-3" /> Render
        </MudText>
    </TitleContent>
    <DialogContent>
        
        <MudGrid>
            <MudItem md="6">
                <MudText Typo="Typo.body1">Resolution</MudText>
            </MudItem>
            <MudItem md="6">
                <MudSelect @bind-Value="@renderRes" Variant="Variant.Outlined">
                    <MudSelectItem Value="1920">FHD 1920x1080</MudSelectItem>
                    <MudSelectItem Value="1080">HD 1080x720</MudSelectItem>
                </MudSelect>
            </MudItem>
            <MudItem md="6">
                <MudText Typo="Typo.body1">Compression</MudText>
            </MudItem>
            <MudItem md="6">
                <MudSelect @bind-Value="@renderQuality" Variant="Variant.Outlined">
                    @foreach (var option in renderQualityOptions)
                    {
                        <MudSelectItem Value="@option.Key">@option.Value</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
        </MudGrid>

    </DialogContent>
    <DialogActions>
        <MudButton Variant="Variant.Filled" Color="Color.Transparent" Class="px-10" OnClick="()=>renderMenuOpen = false">Close</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="px-10" OnClick="@RenderAll">Render</MudButton>
    </DialogActions>
</MudDialog>

@* Whisper Menu *@
<MudDialog @bind-IsVisible="whisperMenuOpen" Options="new DialogOptions() { FullWidth = true }">
    <TitleContent>
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@Icons.Material.Filled.AutoFixHigh" Class="mr-3" /> Extract Lyrics
        </MudText>
    </TitleContent>
    <DialogContent>

        <MudGrid>
            <MudAppBar Color="Color.Transparent" Fixed="false" Elevation="0" Class="py-4">
                <MudText Typo="Typo.subtitle2">GPML Model</MudText>
                <MudSpacer />
                <MudSelect @bind-Value="@modelToUse" Variant="Variant.Outlined">
                    <MudSelectItem Value="GgmlType.Tiny">Faster, least accurate</MudSelectItem>
                    <MudSelectItem Value="GgmlType.Base">Balanced</MudSelectItem>
                    <MudSelectItem Value="GgmlType.Small">Slower, more accurate</MudSelectItem>
                </MudSelect>
            </MudAppBar>
        </MudGrid>

    </DialogContent>
    <DialogActions>
        <MudButton Variant="Variant.Filled" Color="Color.Transparent" Class="px-10" OnClick="()=> whisperMenuOpen = false">Close</MudButton>        
        
        <MudFileUpload T="IBrowserFile" Accept=".mp3, .wav, .ogg" FilesChanged="(Func<IBrowserFile, Task>)UploadAudio" MaximumFileCount="100">
            <ButtonTemplate>
                <MudButton HtmlTag="label"
                           Variant="Variant.Filled"
                           Color="Color.Primary"
                           for="@context.Id">
                    Upload Audio
                    <MudIcon Icon="@Icons.Material.Filled.FileUpload" Title="Upload Audio" />
                </MudButton>
            </ButtonTemplate>
        </MudFileUpload>

    </DialogActions>
</MudDialog>

@* Process Progress Dialog *@
<MudDialog @bind-IsVisible="processProgressOpen" Options="new DialogOptions() { FullWidth = true }">
    <TitleContent>
        <MudText Typo="Typo.h6">
            <MudIcon Icon="@Icons.Material.Filled.AutoFixHigh" Class="mr-3" />@processProgressTitle
        </MudText>
    </TitleContent>
    <DialogContent>

        <MudGrid>
            <MudText Typo="Typo.body1">@processProgressText</MudText> 
                @if (processProgress >= 0)
            {
                <MudProgressLinear Color
                ="Color.Error"  Indeterminate
                ="processProgress == 0 || processProgress >= 100" Value
                ="@processProgress" Class
                ="my-7" />
            }
        </MudGrid>

    </DialogContent>
		<DialogActions>
            @* Make sure the button is only active in render part *@
        @if (processIsRender)
        {
            @if (renderOutputFile != "")
            {
                <MudButton Variant="Variant.Filled" Color="Color.Success" Class="px-10" OnClick="()=> TriggerDownload(renderOutputFile)">Download</MudButton>
            }
            <MudButton Variant="Variant.Filled" Color="Color.Transparent" Class="px-10" OnClick="()=> renderAbort = true">Abort</MudButton>
        }
    </DialogActions>
</MudDialog>

@inject HttpClient HTTP
@code{
    SectionBarWebControl sectionBarControl { get; set; }
    public SKGLView renderPreview { get; set; }
    public string CurrentTime {get;set;} = "";
    static RenderConfig config;
    public List<SkiaSharp.SKTypeface> TypeFaces { get; set; }
    protected override void OnInitialized()
    {
        config = new RenderConfig()
			{
				SubTitlesFont = new SkiaSharp.SKFont(SkiaSharp.SKTypeface.FromFamilyName("Roboto")) { Size = 10 },
				SubtitleColor = SkiaSharp.SKColors.Black,
				ShadowColor = SkiaSharp.SKColors.Blue,
				AspectRatio = 16 / 9.0F,
				ShadowSize = 3,
				ShadowDistance = 4,
				SubtitleLocation = new SkiaSharp.SKPoint(50, 50 * 9 / 16.0F)
			};
    }
    protected override async Task OnInitializedAsync()
    {
        TypeFaces = new List<SkiaSharp.SKTypeface>();
        var availableFont = new string[] {
		"fonts/Jersey15-Regular.ttf",
		"fonts/Anton-Regular.ttf"
	};
        foreach (var font in availableFont)
        {
            var bytes = await HTTP.GetByteArrayAsync(font);
            var ms = new MemoryStream(bytes);
            TypeFaces.Add(SkiaSharp.SKFontManager.Default.CreateTypeface(ms));
        }
        config.SubTitlesFont = new SkiaSharp.SKFont(TypeFaces.First());
        SubtitleEditorFontFamily = config.SubTitlesFont.Typeface.FamilyName;
    }

    bool menuOpen;
    int renderRes = 1920;
    bool renderAbort = false;
    string renderQuality = "medium";
    string renderOutputFile = "";
    bool renderMenuOpen;

    bool processIsRender = true;
    bool processProgressOpen;
    double processProgress = 0;
    string processProgressText = "Working";
    string processProgressTitle = "";
    Dictionary<string, string> renderQualityOptions = new Dictionary<string, string>
        {
    { "ultrafast","Fastest (Lowest quality)"},
    { "medium", "Normal"},
    { "ultraslow", "Slowest (Lossless Quality)" }
        };
    void OpenDrawer()
    {
        menuOpen = true;
    }

    public void SeekUpdate(double t){
        CurrentTime = common.timeToString(t);
        renderPreview.Invalidate();
    }
    void RenderPreview()
    {
        renderPreview.Invalidate();
    }

    protected void OnRenderPaint(SKPaintGLSurfaceEventArgs e)
    {
        var canvas = e.Surface.Canvas;
        canvas.Clear();
        var width = (float)e.Info.Width;
        var height = (float)(e.Info.Width / config.AspectRatio);
        if (height > e.Info.Height)
        {
            height = e.Info.Height;
            width = (float)(height * config.AspectRatio);
        }

        canvas.Translate((e.Info.Width - width) / 2, (e.Info.Height - height) / 2);
        e.Surface.Canvas.DrawRect(0, 0, width, height, new SkiaSharp.SKPaint()
			{
				IsStroke = true,
				StrokeWidth = 2,
				Color = SkiaSharp.SKColors.Gray
			});
        float scale = width / 100;
        e.Surface.Canvas.Scale(scale, scale);

        config.TargetSize = new SkiaSharp.SKSize() { Width = width, Height = height };

        sectionBarControl.RenderCurrentFrame(
            e.Surface.Canvas, config);
        e.Surface.Canvas.Scale(1 / scale, 1 / scale);
        canvas.Translate(-(e.Info.Width - width) / 2, -(e.Info.Height - height) / 2);
    }

    // Common Helpers
    bool hasInitFFMPEG = false;
    System.Text.StringBuilder FFLog = new System.Text.StringBuilder();
    async Task GetFFMpeg()
    {
        FFLog.Clear();
        if (FFmpegFactory.Runtime == null)
        {
            Console.WriteLine("Get FFMpeg");
            await FFmpegFactory.Init(Runtime);
            processProgressText = "Downloading FFmpeg";
            StateHasChanged();
            //create an instance
            VideoClipEditor.FFMpeg = FFmpegFactory.CreateFFmpeg();
            //download all dependencies from cdn
            await VideoClipEditor.FFMpeg.Load(); //parameter false means not to trigger events in ffmpeg Clase instance

        }
        //if (FFmpegFactory.Runtime == null)
        // In cas renderer has already called it.
        if (!hasInitFFMPEG)
        {
            hasInitFFMPEG = true;
            processProgressText = "Downloading FFMPEG...";
            StateHasChanged();
            //initialize Library
            await FFmpegFactory.Init(Runtime);
        }

    }

    // Render Output
    async Task TriggerDownload(string fName)
    {
        var outBuffer = await VideoClipEditor.FFMpeg.ReadFile(fName);
        await Runtime.InvokeVoidAsync("downloadFile", "Render Output" + Path.GetExtension(fName), outBuffer);
    }
    async Task RenderAll()
    {
        processIsRender = true;
        processProgressTitle = "Creating your video";
        // Prepare UI
        renderMenuOpen = false;
        processProgressOpen = true;
        processProgress = 0;
        StateHasChanged();
        await GetFFMpeg();
        void durationExtracter(Logs l)
        {
            FFLog.AppendLine(l.Message);
            if (l.Message.Trim().StartsWith("frame="))
            {
                var fNum = int.Parse(l.Message.Split("fps")[0].Trim().Substring(6).Trim());
                processProgressText = "Extracted " + fNum + " frames";
                var total = sectionBarControl.sectionBar.Maximum * 30;
                processProgressText = "Encoded frame " + fNum + " of " + total;
                processProgress = fNum / (double)total * 100;
                StateHasChanged();
            }

            Console.WriteLine("ffmpeg: " + l.Message);
        };
        FFmpegFactory.Logger += durationExtracter;

        processProgressText = "Creating Frames";
        renderAbort = false;

        //Render Frames
        config.TargetSize = new SkiaSharp.SKSize() { Width = renderRes, Height = renderRes / config.AspectRatio };
        for (int fi = 0; fi < sectionBarControl.sectionBar.Maximum * 30; fi++)
        {
            var t = fi / 30.0D;
            using (var skBitmap = new SkiaSharp.SKBitmap((int)config.TargetSize.Width, (int)config.TargetSize.Height))
            {
                using (var ms = new MemoryStream())
                {

                    var canvas = new SkiaSharp.SKCanvas(skBitmap);
                    var s = skBitmap.Width / 100;
                    canvas.Scale(s, s);
                    sectionBarControl.RenderCurrentFrameAtT(canvas, t, config);
                    skBitmap.Encode(ms, SkiaSharp.SKEncodedImageFormat.Jpeg, 100);
                    var buffer = ms.ToArray();
                    var jpgName = "FR" + (fi + 1).ToString().PadLeft(4, '0') + ".jpg";
                    VideoClipEditor.FFMpeg.WriteFile(jpgName, buffer);
                    //var readOut = await VideoClipEditor.FFMpeg.ReadFile(jpgName);
                    //VideoClipEditor.FFMpeg.WriteFile("FR%04d.jpg", buffer);
                    processProgress = t / sectionBarControl.sectionBar.Maximum * 100;
                    await Task.Delay(1);
                }
            }
            GC.Collect();
            StateHasChanged();
        }
        processProgress = 0;
        processProgressText = "Encoding video";
        StateHasChanged();
        var fName = "output.mp4";
        await VideoClipEditor.FFMpeg.Run("-framerate", "30", "-r", "30", "-i", "FR%04d.jpg", "-c:v", "libx264", "-crf", "18", "-preset", renderQuality, fName);
        renderOutputFile = fName;

        FFmpegFactory.Logger -= durationExtracter;
        processProgressText = "Your file is ready to be downloaded";
        processProgress = -1;
        Snackbar.Add("Video compiled successfully");
    }

    //Whisper
    bool firstRender = true;
    GgmlType modelToUse = GgmlType.Tiny;
    bool whisperMenuOpen = false;
    Dictionary<GgmlType, WhisperFactory> whisperFactory = new Dictionary<GgmlType, WhisperFactory>();

    Dictionary<GgmlType, WhisperProcessor> whisperProcessor = new Dictionary<GgmlType, WhisperProcessor>();

    protected async Task UploadAudio(IBrowserFile file)
    {
        processProgressTitle = "Extract Lyrics";
        var stream = file.OpenReadStream(10000000);
        var mp3 = new byte[file.Size];

        //read all bytes
        await stream.ReadAsync(mp3);

        whisperMenuOpen = false;
        processProgressOpen = true;
        StateHasChanged();
        processIsRender = false;

        await GetFFMpeg();
        double duration = 0;
        void durationExtracter(Logs l)
        {
            FFLog.AppendLine(l.Message);
            if (l.Message.Trim().StartsWith("Duration:"))
            {
                var d = l.Message.Trim().Substring(10).Split(',')[0];
                var parts = d.Split(':', '.').Select(p => int.Parse(p)).ToArray();
                var h = parts[0];
                var m = parts[1];
                var s = parts[2];
                var f = parts[3];
                duration = h * 3600 + m * 60 + s;
            }

            Console.WriteLine("ffmpeg: " + l.Message);
        };
        void progressUpdate(Progress p){
            processProgress = p.Ratio * 100;
            processProgressText = Math.Round(processProgress).ToString() + "% converted";
            StateHasChanged();
        }
        FFmpegFactory.Logger += durationExtracter;
        FFmpegFactory.Progress += progressUpdate;
        processProgressText = "Converting to WAVE format";
        StateHasChanged();

        VideoClipEditor.FFMpeg.WriteFile("input.mp3", mp3);
        await VideoClipEditor.FFMpeg.Run("-i", "input.mp3","-ar", "16000", "output.wav");
        FFmpegFactory.Logger -= durationExtracter;
        FFmpegFactory.Progress -= progressUpdate;

        var wave = await VideoClipEditor.FFMpeg.ReadFile("output.wav");

        Console.WriteLine("Downloading Gpml");
        if (!whisperFactory.ContainsKey(modelToUse))
        {
            processProgressText = "Downloading GPML model";
            using var memoryStream = new MemoryStream();
            var model = await WhisperGgmlDownloader.GetGgmlModelAsync(GgmlType.Tiny, QuantizationType.Q5_1);
            await model.CopyToAsync(memoryStream);
            //await model.CopyToAsync(memoryStream);
            whisperFactory[modelToUse] = WhisperFactory.FromBuffer(memoryStream.ToArray());
        }
        processProgressText = "Extracting Lyrics";
        StateHasChanged();
        processProgress = 0;
        Console.WriteLine("Begin whisper");
        if (!whisperProcessor.ContainsKey(modelToUse))
        {
            whisperProcessor[modelToUse] = whisperFactory[modelToUse].CreateBuilder()
            .WithPrintProgress()
            .WithPrintResults()
            .WithLanguage("en")
            .Build();
            StateHasChanged();
        }

        sectionBarControl.sectionBar.Layers[2].Clear();
        int totalWords = 0;
        int totalSubs = 0;
        double confidance = 0;
        await foreach (var result in whisperProcessor[modelToUse]!.ProcessAsync(new MemoryStream(wave)))
        {
            Console.WriteLine($"{result.Start}->{result.End}: {result.Text}");
            totalWords += result.Text.Split(' ').Length;
            // Add a new clip for this
            var subClip = new SubtitleClip(result.Start.TotalSeconds, result.End.TotalSeconds, result.Text);
            sectionBarControl.sectionBar.Layers[2].Add(subClip);
            sectionBarControl.ResetMaxTime();

            processProgressText = (++totalSubs) + ": " + result.Text + " [" + result.Probability + "]";
            confidance += result.Probability;
            sectionBarControl.Invalidate();
            processProgress = (result.End.TotalSeconds / duration) * 100;
            StateHasChanged();
        }
        confidance /= totalSubs;
        processProgressText = "All done!";
        processProgress = -1;
        sectionBarControl.sectionBar.Layers[4].Clear();
        sectionBarControl.sectionBar.Layers[4].Add(new AudioClip(0, duration, mp3, file.Name));
        sectionBarControl.sectionBar.ResetMaxTime();
        Snackbar.Add($"Audio was processed successfully and lyrics where added to the timeline. Total {totalSubs} lyrics containing {totalWords} words exracted with an overall confidance of {confidance}.");
        StateHasChanged();
    }

    //Common Clip Editing
    Clip ClipUnderEditing;

    public void EditClipRequest(Clip clip)
    {
        ClipUnderEditing = clip;
        if (clip == null)
            return;
        if (clip is SubtitleClip)
        {
            ClipEditorSource = ClipUnderEditing.Source;
            SubtitleEditorFontFamily = config.SubTitlesFont.Typeface.FamilyName;
            SubtitleEditorFontSize = config.SubTitlesFont.Size;
            SubtitleEditorYPosition = (float)(config.SubtitleLocation.Y * config.AspectRatio);
            SubtitleEditorShadowSize = config.ShadowSize;
            SubtitleEditorShadowDistance = config.ShadowDistance;
            SubtitleEditorTextColor = SKColorToMud(config.SubtitleColor);
            SubtitleEditorShadowColor = SKColorToMud(config.ShadowColor);
            SubtitleEditorOverlap = config.SubtitleOverlap;
            ClipEditorStartingHH = TimeSpan.FromSeconds(ClipUnderEditing.Start).Hours;
            ClipEditorStartingMM = TimeSpan.FromSeconds(ClipUnderEditing.Start).Minutes;
            ClipEditorStartingSS = TimeSpan.FromSeconds(ClipUnderEditing.Start).Seconds;
            ClipEditorStartingFF = (int)(TimeSpan.FromSeconds(ClipUnderEditing.Start).Milliseconds * 30 / 1000);
            var duration = ClipUnderEditing.End - ClipUnderEditing.Start;
            ClipEditorDurationHH = TimeSpan.FromSeconds(duration).Hours;
            ClipEditorDurationMM = TimeSpan.FromSeconds(duration).Minutes;
            ClipEditorDurationSS = TimeSpan.FromSeconds(duration).Seconds;
            ClipEditorDurationFF = (int)(TimeSpan.FromSeconds(duration).Milliseconds * 30 / 1000);
        }
        else if(clip is PhotoClip)
        {
            var photoClip = (PhotoClip)ClipUnderEditing;
            ClipEditorSource = photoClip.Source;
            PhotoEditorData = photoClip.Data;
            GraphicEditorSize = photoClip.Size;
            GraphicEditorXPosition = photoClip.X;
            GraphicEditorYPosition = photoClip.Y;
            ClipEditorStartingHH = TimeSpan.FromSeconds(ClipUnderEditing.Start).Hours;
            ClipEditorStartingMM = TimeSpan.FromSeconds(ClipUnderEditing.Start).Minutes;
            ClipEditorStartingSS = TimeSpan.FromSeconds(ClipUnderEditing.Start).Seconds;
            ClipEditorStartingFF = (int)(TimeSpan.FromSeconds(ClipUnderEditing.Start).Milliseconds * 30 / 1000);
            var duration = ClipUnderEditing.End - ClipUnderEditing.Start;
            ClipEditorDurationHH = TimeSpan.FromSeconds(duration).Hours;
            ClipEditorDurationMM = TimeSpan.FromSeconds(duration).Minutes;
            ClipEditorDurationSS = TimeSpan.FromSeconds(duration).Seconds;
            ClipEditorDurationFF = (int)(TimeSpan.FromSeconds(duration).Milliseconds * 30 / 1000);
        }
        else if (clip is VideoClip)
        {
            var videoClip = (VideoClip)ClipUnderEditing;
            ClipEditorSource = videoClip.Source;
            VideoEditorData = videoClip.Data;
            GraphicEditorSize = videoClip.Size;
            GraphicEditorXPosition = videoClip.X;
            GraphicEditorYPosition = videoClip.Y;
            ClipEditorStartingHH = TimeSpan.FromSeconds(ClipUnderEditing.Start).Hours;
            ClipEditorStartingMM = TimeSpan.FromSeconds(ClipUnderEditing.Start).Minutes;
            ClipEditorStartingSS = TimeSpan.FromSeconds(ClipUnderEditing.Start).Seconds;
            ClipEditorStartingFF = (int)(TimeSpan.FromSeconds(ClipUnderEditing.Start).Milliseconds * 30 / 1000);
            var duration = ClipUnderEditing.End - ClipUnderEditing.Start;
            ClipEditorDurationHH = TimeSpan.FromSeconds(duration).Hours;
            ClipEditorDurationMM = TimeSpan.FromSeconds(duration).Minutes;
            ClipEditorDurationSS = TimeSpan.FromSeconds(duration).Seconds;
            ClipEditorDurationFF = (int)(TimeSpan.FromSeconds(duration).Milliseconds * 30 / 1000);
        }
    }

    // Subtitle Clip Editor

    string ClipEditorSource { get; set; }
    string SubtitleEditorFontFamily { get; set; }
    float SubtitleEditorFontSize { get; set; }
    float SubtitleEditorYPosition { get; set; }
    float SubtitleEditorShadowSize { get; set; }
    float SubtitleEditorShadowDistance { get; set; }
    MudColor SubtitleEditorTextColor { get; set; }
    MudColor SubtitleEditorShadowColor { get; set; }
    double SubtitleEditorOverlap { get; set; }
    double ClipEditorStartingHH {get;set;}
    double ClipEditorStartingMM {get;set;}
    double ClipEditorStartingSS {get;set;}
    double ClipEditorStartingFF {get;set;}
    double ClipEditorDurationHH {get;set;}
    double ClipEditorDurationMM {get;set;}
    double ClipEditorDurationSS {get;set;}
    double ClipEditorDurationFF { get; set; }

    SkiaSharp.SKColor MudColorToSK(MudColor mud)
    {
        return new SkiaSharp.SKColor(mud.R, mud.G, mud.B, mud.A);
    }
    MudColor SKColorToMud(SkiaSharp.SKColor sk)
    {
        return new MudColor(sk.Red, sk.Green, sk.Blue, sk.Alpha);
    }
    public void SubtitleEditorOnAChange(SubtitleEditor.Editors.SubtitleClipEditor subtitleEditor)
    {

        if (ClipUnderEditing == null)
            return;
        if (ClipUnderEditing is SubtitleClip)
        {
            ClipUnderEditing.Source = subtitleEditor.Text;
            config.SubTitlesFont = new SkiaSharp.SKFont(TypeFaces.Find(tf => tf.FamilyName == subtitleEditor.FontFamily), subtitleEditor.FontSize);
            config.SubtitleLocation = new SkiaSharp.SKPoint(config.SubtitleLocation.X, subtitleEditor.YPosition / config.AspectRatio);
            config.ShadowSize = subtitleEditor.ShadowSize;
            config.ShadowDistance = subtitleEditor.ShadowDistance;
            config.SubtitleOverlap = (float)subtitleEditor.Overlap;
            config.SubtitleColor = MudColorToSK(subtitleEditor.TextColor);
            config.ShadowColor = MudColorToSK(subtitleEditor.ShadowColor);
            double duration(double h, double m, double s, double f)
            {
                return h * 3600 + m * 60 + s + f / 30;
            }
            ClipUnderEditing.Start = duration(
                subtitleEditor.StartingHH,
                subtitleEditor.StartingMM,
                subtitleEditor.StartingSS,
                subtitleEditor.StartingFF);
            ClipUnderEditing.End = ClipUnderEditing.Start + duration(
                subtitleEditor.DurationHH,
                subtitleEditor.DurationMM,
                subtitleEditor.DurationSS,
                subtitleEditor.DurationFF);
            ClipEditorSource = subtitleEditor.Text;

            // Round 2
            SubtitleEditorFontFamily = config.SubTitlesFont.Typeface.FamilyName;
            SubtitleEditorFontSize = config.SubTitlesFont.Size;
            SubtitleEditorYPosition = config.SubtitleLocation.Y * config.AspectRatio;
            SubtitleEditorShadowSize = config.ShadowSize;
            SubtitleEditorShadowDistance = config.ShadowDistance;
            SubtitleEditorTextColor = SKColorToMud(config.SubtitleColor);
            SubtitleEditorShadowColor = SKColorToMud(config.ShadowColor);
            SubtitleEditorOverlap = config.SubtitleOverlap;
            ClipEditorStartingHH = subtitleEditor.StartingHH;
            ClipEditorStartingMM = subtitleEditor.StartingMM;
            ClipEditorStartingSS = subtitleEditor.StartingSS;
            ClipEditorStartingFF = subtitleEditor.StartingFF;
            ClipEditorDurationHH = subtitleEditor.DurationHH;
            ClipEditorDurationMM = subtitleEditor.DurationMM;
            ClipEditorDurationSS = subtitleEditor.DurationSS;
            ClipEditorDurationFF = subtitleEditor.DurationFF;
            sectionBarControl.Invalidate();
            renderPreview.Invalidate();
        }
    }

    // Photo Clip Editor

    protected SkiaSharp.SKBitmap PhotoEditorData { get; set; }
    protected float GraphicEditorSize { get; set; }
    protected float GraphicEditorXPosition {get; set; }
    protected float GraphicEditorYPosition { get; set; }
    public void PhotoEditorOnAChange(SubtitleEditor.Editors.PhotoClipEditor photoEditor)
    {
        if (ClipUnderEditing == null)
            return;
        if (ClipUnderEditing is PhotoClip)
        {
            var photoClip = (PhotoClip)ClipUnderEditing;
            photoClip.Source = photoEditor.SelectedImage;
            photoClip.Data = photoEditor.SelectedImageData;
            photoClip.Size = photoEditor.Size;
            photoClip.X = photoEditor.XPosition;
            photoClip.Y = photoEditor.YPosition;
            double duration(double h, double m, double s, double f)
            {
                return h * 3600 + m * 60 + s + f / 30;
            }
            ClipUnderEditing.Start = duration(
                photoEditor.StartingHH,
                photoEditor.StartingMM,
                photoEditor.StartingSS,
                photoEditor.StartingFF);
            ClipUnderEditing.End = ClipUnderEditing.Start + duration(
                photoEditor.DurationHH,
                photoEditor.DurationMM,
                photoEditor.DurationSS,
                photoEditor.DurationFF);

            // Round 2
            ClipEditorSource = photoEditor.SelectedImage;
            PhotoEditorData = photoEditor.SelectedImageData;
            GraphicEditorSize = photoEditor.Size;
            GraphicEditorXPosition = photoEditor.XPosition;
            GraphicEditorYPosition = photoEditor.YPosition;
            ClipEditorStartingHH = photoEditor.StartingHH;
            ClipEditorStartingMM = photoEditor.StartingMM;
            ClipEditorStartingSS = photoEditor.StartingSS;
            ClipEditorStartingFF = photoEditor.StartingFF;
            ClipEditorDurationHH = photoEditor.DurationHH;
            ClipEditorDurationMM = photoEditor.DurationMM;
            ClipEditorDurationSS = photoEditor.DurationSS;
            ClipEditorDurationFF = photoEditor.DurationFF;
            sectionBarControl.Invalidate();
            renderPreview.Invalidate();
        }
    }


    // Video Clip Editor

    protected SkiaSharp.SKBitmap[] VideoEditorData { get; set; }
    public void VideoEditorOnAChange(SubtitleEditor.Editors.VideoClipEditor videoEditor)
    {
        if (ClipUnderEditing == null)
            return;
        if (ClipUnderEditing is VideoClip)
        {
            var videoClip = (VideoClip)ClipUnderEditing;
            videoClip.Source = videoEditor.SelectedVideo;
            videoClip.Data = videoEditor.SelectedVideoData; 
            sectionBarControl.ResetMaxTime();
            videoClip.Size = videoEditor.Size;
            videoClip.X = videoEditor.XPosition;
            videoClip.Y = videoEditor.YPosition;
            double duration(double h, double m, double s, double f)
            {
                return h * 3600 + m * 60 + s + f / 30;
            }
            ClipUnderEditing.Start = duration(
                videoEditor.StartingHH,
                videoEditor.StartingMM,
                videoEditor.StartingSS,
                videoEditor.StartingFF);
            ClipUnderEditing.End = ClipUnderEditing.Start + duration(
                videoEditor.DurationHH,
                videoEditor.DurationMM,
                videoEditor.DurationSS,
                videoEditor.DurationFF);

            // Round 2
            ClipEditorSource = videoEditor.SelectedVideo;
            VideoEditorData = videoEditor.SelectedVideoData;
            GraphicEditorSize = videoEditor.Size;
            GraphicEditorXPosition = videoEditor.XPosition;
            GraphicEditorYPosition = videoEditor.YPosition;
            ClipEditorStartingHH = videoEditor.StartingHH;
            ClipEditorStartingMM = videoEditor.StartingMM;
            ClipEditorStartingSS = videoEditor.StartingSS;
            ClipEditorStartingFF = videoEditor.StartingFF;
            ClipEditorDurationHH = videoEditor.DurationHH;
            ClipEditorDurationMM = videoEditor.DurationMM;
            ClipEditorDurationSS = videoEditor.DurationSS;
            ClipEditorDurationFF = videoEditor.DurationFF;
            sectionBarControl.Invalidate();
            renderPreview.Invalidate();
        }
    }

}
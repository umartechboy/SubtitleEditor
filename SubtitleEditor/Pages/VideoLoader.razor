@using FFmpegBlazor
@inject IJSRuntime Runtime
@using Microsoft.AspNetCore.Components.Forms
@using MudBlazor
<div style="align-content: center">
    <center>
        <MudFileUpload T="IBrowserFile" FilesChanged="UploadFiles">
            <ButtonTemplate>
                <MudButton HtmlTag="label"
                           Variant="Variant.Filled"
                           Color="Color.Primary"
                           StartIcon="@Icons.Material.Filled.CloudUpload"
                           for="@context.Id">
                    Upload File
                </MudButton>
            </ButtonTemplate>
        </MudFileUpload>
        @if (started)
        {
            <div style="100%">
                <MudProgressLinear Color ="Color.Default" Value ="@ProgressValue" />
                <span>Decoding video (@ProgressValue%)</span>
            </div>
        }
        @if (isVideo)
        {
            <video width="100%" height="200px" autoplay controls src="@VideoPreviewUrl" />
        }
        @if (isImage)
        {
            <img width="100%" height="200px" src="@ImagePreviewUrl" />
        }
        <h1>@Title</h1>
    </center>
</div>

@code {
    [Parameter]
    public string Title { get; set; } = "Video Title";
    [Parameter]
    public string VideoPreviewUrl { get; set; } = "";
    [Parameter]
    public string ImagePreviewUrl { get; set; } = "";

    bool isVideo = false;
    bool isImage = false;
    int ProgressValue = 10;
    FFMPEG ff;
    byte[] buffer;
    bool started = false;
    double parsedVideoDuration = 0;
    int parsedVideoFramesModulo = 0;
    double parsedVideoFps = 0;
    protected override async Task OnInitializedAsync()
    {
        if (FFmpegFactory.Runtime == null)
        {
            FFmpegFactory.Logger += l =>
            {
                // Lets try to parse info:
                if (l.Message.StartsWith("Duration:"))
                {
                    var d = l.Message.Substring(10).Split(',')[0];
                    var parts = d.Split(':', '.').Select(p => int.Parse(p)).ToArray();
                    var h = parts[0];
                    var m = parts[1];
                    var s = parts[2];
                    var f = parts[3];
                    parsedVideoDuration = h * 3600 + m * 60 + s;
                }

                else if (l.Message.StartsWith(" fps, "))
                {
                    var fps = double.Parse(l.Message.Substring(l.Message.IndexOf(" fps, ")).Split(',').Last());
                    parsedVideoFps = fps;
                }

                Console.WriteLine("ffmpeg: " + l.Message);
            };
            FFmpegFactory.Progress += ProgressChange;
        }

        //initialize Library
        await FFmpegFactory.Init(Runtime);
    }


    public async Task UploadFiles(IBrowserFile file)
    {
        isImage = false;
        isVideo = false;
        parsedVideoDuration = 0;
        parsedVideoFps = 0;
        //read all bytes
        using var stream = file.OpenReadStream(100000000); //Max size for file that can be read
        buffer = new byte[file.Size];

        //read all bytes
        await stream.ReadAsync(buffer);

        var ext = System.IO.Path.GetExtension(file.Name).ToLower();
        var images = new string []{ ".jpg", ".png", ".bmp"};
        if (images.Contains(ext)) // treat image
        {
            isImage = true;
            ImagePreviewUrl = $"data:{file.ContentType};base64,{Convert.ToBase64String(buffer)}";
        }
        else
        {
            isVideo = true;
            //create a video link from buffer to that video can be played
            VideoPreviewUrl = FFmpegFactory.CreateURLFromBuffer(buffer, "loaded file.mp4", file.ContentType);

            ProgressValue = 0;
            started = true;

            StateHasChanged();
            //create an instance
            ff = FFmpegFactory.CreateFFmpeg();
            //download all dependencies from cdn
            await ff.Load(); //parameter false means not to trigger events in ffmpeg Clase instance

            if (!ff.IsLoaded) return;

            //write buffer to in-memory files
            ff.WriteFile("input.mp4", buffer);

            //Pass CLI argument here equivalent to ffmpeg -i myFile.mp4 output.mp3
            await ff.Run("-i", "input.mp4", "-vf", "fps=1", "output_%04d.png");
            if (parsedVideoFps != 0)
            {
                var totalFrames = parsedVideoDuration / parsedVideoFps + parsedVideoFramesModulo;
                Console.WriteLine("Expecting " + totalFrames + " frames");
            }
            var frames = new List<byte[]>();
            for (int i = 0; i <= 9999; i++)
            {
                try
                {
                    var frame = await ff.ReadFile("output_" + i.ToString().PadLeft(4, '0') + ".png");
                    frames.Add(frame);
                }
                catch
                {
                    break;
                }
            }
            //delete in-memory file
            //ff.UnlinkFile("myFile.mp4");
            //reRender DOM
            started = false;
            StateHasChanged();
        }
    }
    void ProgressChange(Progress m)
    {
        ProgressValue = (int)(m.Ratio * 100.0f);
        if (ProgressValue < 0)
            ProgressValue = 0;
        else if (ProgressValue > 100)
            ProgressValue = 100;
        // Console.WriteLine($"Progress {m.Ratio}");

        if (m.Ratio >= 1)
        {
            started = false;
            StateHasChanged();
        }
        StateHasChanged();

    }
}
